
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+ 6)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR(0)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED  

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
lab:    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+0], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+16], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+24], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+32], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+40], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+48], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+56], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+64], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+72], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+80], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+88], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+96], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+104], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+112], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+120], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+128], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+136], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+144], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+152], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+160], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+168], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+176], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl+184], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl+192], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl+200], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl+208], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl+216], rax
    
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl+224], rax
    

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

push qword 12345678
mov rax, qword [fvar_tbl+224]
push rax
mov rax, qword [fvar_tbl+200]
push rax
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 5
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length4
count_env_length4:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length4
    jmp count_env_length4
end_count_env_length4: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env4 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env4:
    cmp rsi, rcx
    je end_copy_old_env4 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env4

extent_first_env4:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env4:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params4:
    cmp rcx, rdx 
    je end_copy_params4 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params4
end_copy_params4:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode4) 
    jmp Lcont4
Lcode4:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length3
count_env_length3:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length3
    jmp count_env_length3
end_count_env_length3: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env3 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env3:
    cmp rsi, rcx
    je end_copy_old_env3 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env3

extent_first_env3:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env3:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params3:
    cmp rcx, rdx 
    je end_copy_params3 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params3
end_copy_params3:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode3) 
    jmp Lcont3
Lcode3:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length2
count_env_length2:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length2
    jmp count_env_length2
end_count_env_length2: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env2 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env2:
    cmp rsi, rcx
    je end_copy_old_env2 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env2

extent_first_env2:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env2:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params2:
    cmp rcx, rdx 
    je end_copy_params2 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params2
end_copy_params2:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode2) 
    jmp Lcont2
Lcode2:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 2 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil2

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list2:
    cmp rdi, rcx
    je end_generate_opt_list2 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list2
  end_generate_opt_list2:
    mov rdx, 2 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start2
  put_nil2:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start2:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse1
mov rax, const_tbl+1
jmp Lexit1
Lelse1:
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse0
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit0
Lelse0:
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, qword [fvar_tbl+232]
push rax
push 4
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit0:
Lexit1:
leave
    ret 
Lcont2:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
leave
    ret 
Lcont3:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont4:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+232], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length8
count_env_length8:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length8
    jmp count_env_length8
end_count_env_length8: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env8 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env8:
    cmp rsi, rcx
    je end_copy_old_env8 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env8

extent_first_env8:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env8:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params8:
    cmp rcx, rdx 
    je end_copy_params8 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params8
end_copy_params8:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode8) 
    jmp Lcont8
Lcode8:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length7
count_env_length7:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length7
    jmp count_env_length7
end_count_env_length7: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env7 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env7:
    cmp rsi, rcx
    je end_copy_old_env7 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env7

extent_first_env7:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env7:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params7:
    cmp rcx, rdx 
    je end_copy_params7 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params7
end_copy_params7:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode7) 
    jmp Lcont7
Lcode7:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length6
count_env_length6:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length6
    jmp count_env_length6
end_count_env_length6: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env6 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env6:
    cmp rsi, rcx
    je end_copy_old_env6 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env6

extent_first_env6:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env6:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params6:
    cmp rcx, rdx 
    je end_copy_params6 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params6
end_copy_params6:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode6) 
    jmp Lcont6
Lcode6:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse5
mov rax, qword [rbp + 8 * (4 + 1)]
jmp Lexit5
Lelse5:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 2
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit5:
leave
    ret 
Lcont6:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
leave
    ret 
Lcont7:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont8:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+240], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length12
count_env_length12:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length12
    jmp count_env_length12
end_count_env_length12: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env12 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env12:
    cmp rsi, rcx
    je end_copy_old_env12 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env12

extent_first_env12:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env12:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params12:
    cmp rcx, rdx 
    je end_copy_params12 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params12
end_copy_params12:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode12) 
    jmp Lcont12
Lcode12:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length11
count_env_length11:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length11
    jmp count_env_length11
end_count_env_length11: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env11 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env11:
    cmp rsi, rcx
    je end_copy_old_env11 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env11

extent_first_env11:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env11:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params11:
    cmp rcx, rdx 
    je end_copy_params11 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params11
end_copy_params11:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode11) 
    jmp Lcont11
Lcode11:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length10
count_env_length10:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length10
    jmp count_env_length10
end_count_env_length10: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env10 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env10:
    cmp rsi, rcx
    je end_copy_old_env10 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env10

extent_first_env10:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env10:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params10:
    cmp rcx, rdx 
    je end_copy_params10 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params10
end_copy_params10:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode10) 
    jmp Lcont10
Lcode10:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse9
mov rax, qword [rbp + 8 * (4 + 1)]
jmp Lexit9
Lelse9:
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 2)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit9:
leave
    ret 
Lcont10:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
leave
    ret 
Lcont11:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont12:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+248], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length19
count_env_length19:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length19
    jmp count_env_length19
end_count_env_length19: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env19 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env19:
    cmp rsi, rcx
    je end_copy_old_env19 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env19

extent_first_env19:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env19:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params19:
    cmp rcx, rdx 
    je end_copy_params19 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params19
end_copy_params19:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode19) 
    jmp Lcont19
Lcode19:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 0 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil19

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list19:
    cmp rdi, rcx
    je end_generate_opt_list19 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list19
  end_generate_opt_list19:
    mov rdx, 0 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start19
  put_nil19:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start19:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+200]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length18
count_env_length18:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length18
    jmp count_env_length18
end_count_env_length18: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env18 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env18:
    cmp rsi, rcx
    je end_copy_old_env18 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env18

extent_first_env18:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env18:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params18:
    cmp rcx, rdx 
    je end_copy_params18 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params18
end_copy_params18:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode18) 
    jmp Lcont18
Lcode18:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length17
count_env_length17:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length17
    jmp count_env_length17
end_count_env_length17: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env17 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env17:
    cmp rsi, rcx
    je end_copy_old_env17 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env17

extent_first_env17:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env17:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params17:
    cmp rcx, rdx 
    je end_copy_params17 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params17
end_copy_params17:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode17) 
    jmp Lcont17
Lcode17:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length16
count_env_length16:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length16
    jmp count_env_length16
end_count_env_length16: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env16 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env16:
    cmp rsi, rcx
    je end_copy_old_env16 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env16

extent_first_env16:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env16:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params16:
    cmp rcx, rdx 
    je end_copy_params16 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params16
end_copy_params16:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode16) 
    jmp Lcont16
Lcode16:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [fvar_tbl+32]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse15
mov rax, const_tbl+1
jmp Lexit15
Lelse15:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [fvar_tbl+32]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse14
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit14
Lelse14:
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [fvar_tbl+32]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse13
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit13
Lelse13:
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit13:
Lexit14:
Lexit15:
leave
    ret 
Lcont16:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont17:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont18:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont19:
mov qword [fvar_tbl+256], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+200]
push rax
mov rax, qword [fvar_tbl+248]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length23
count_env_length23:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length23
    jmp count_env_length23
end_count_env_length23: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env23 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env23:
    cmp rsi, rcx
    je end_copy_old_env23 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env23

extent_first_env23:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env23:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params23:
    cmp rcx, rdx 
    je end_copy_params23 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params23
end_copy_params23:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode23) 
    jmp Lcont23
Lcode23:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length22
count_env_length22:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length22
    jmp count_env_length22
end_count_env_length22: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env22 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env22:
    cmp rsi, rcx
    je end_copy_old_env22 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env22

extent_first_env22:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env22:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params22:
    cmp rcx, rdx 
    je end_copy_params22 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params22
end_copy_params22:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode22) 
    jmp Lcont22
Lcode22:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 0 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil22

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list22:
    cmp rdi, rcx
    je end_generate_opt_list22 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list22
  end_generate_opt_list22:
    mov rdx, 0 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start22
  put_nil22:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start22:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+1
push rax
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length21
count_env_length21:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length21
    jmp count_env_length21
end_count_env_length21: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env21 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env21:
    cmp rsi, rcx
    je end_copy_old_env21 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env21

extent_first_env21:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env21:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params21:
    cmp rcx, rdx 
    je end_copy_params21 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params21
end_copy_params21:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode21) 
    jmp Lcont21
Lcode21:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse20
mov rax, qword [rbp + 8 * (4 + 0)]
jmp Lexit20
Lelse20:
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit20:
leave
    ret 
Lcont21:
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont22:
leave
    ret 
Lcont23:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+264], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length24
count_env_length24:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length24
    jmp count_env_length24
end_count_env_length24: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env24 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env24:
    cmp rsi, rcx
    je end_copy_old_env24 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env24

extent_first_env24:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env24:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params24:
    cmp rcx, rdx 
    je end_copy_params24 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params24
end_copy_params24:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode24) 
    jmp Lcont24
Lcode24:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 0 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil24

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list24:
    cmp rdi, rcx
    je end_generate_opt_list24 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list24
  end_generate_opt_list24:
    mov rdx, 0 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start24
  put_nil24:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start24:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont24:
mov qword [fvar_tbl+272], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+24]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length29
count_env_length29:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length29
    jmp count_env_length29
end_count_env_length29: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env29 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env29:
    cmp rsi, rcx
    je end_copy_old_env29 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env29

extent_first_env29:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env29:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params29:
    cmp rcx, rdx 
    je end_copy_params29 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params29
end_copy_params29:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode29) 
    jmp Lcont29
Lcode29:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length28
count_env_length28:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length28
    jmp count_env_length28
end_count_env_length28: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env28 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env28:
    cmp rsi, rcx
    je end_copy_old_env28 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env28

extent_first_env28:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env28:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params28:
    cmp rcx, rdx 
    je end_copy_params28 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params28
end_copy_params28:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode28) 
    jmp Lcont28
Lcode28:
    push rbp
    mov rbp, rsp 

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length27
count_env_length27:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length27
    jmp count_env_length27
end_count_env_length27: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env27 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env27:
    cmp rsi, rcx
    je end_copy_old_env27 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env27

extent_first_env27:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env27:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params27:
    cmp rcx, rdx 
    je end_copy_params27 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params27
end_copy_params27:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode27) 
    jmp Lcont27
Lcode27:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit26
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse25
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [fvar_tbl+280]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit25
Lelse25:
mov rax, const_tbl+2
Lexit25:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit26

Lexit26:
leave
    ret 
Lcont27:
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont28:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont29:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+280], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+136]
push rax
mov rax, qword [fvar_tbl+240]
push rax
push 2
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length32
count_env_length32:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length32
    jmp count_env_length32
end_count_env_length32: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env32 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env32:
    cmp rsi, rcx
    je end_copy_old_env32 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env32

extent_first_env32:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env32:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params32:
    cmp rcx, rdx 
    je end_copy_params32 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params32
end_copy_params32:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode32) 
    jmp Lcont32
Lcode32:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length31
count_env_length31:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length31
    jmp count_env_length31
end_count_env_length31: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env31 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env31:
    cmp rsi, rcx
    je end_copy_old_env31 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env31

extent_first_env31:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env31:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params31:
    cmp rcx, rdx 
    je end_copy_params31 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params31
end_copy_params31:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode31) 
    jmp Lcont31
Lcode31:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+41
push rax
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length30
count_env_length30:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length30
    jmp count_env_length30
end_count_env_length30: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env30 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env30:
    cmp rsi, rcx
    je end_copy_old_env30 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env30

extent_first_env30:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env30:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params30:
    cmp rcx, rdx 
    je end_copy_params30 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params30
end_copy_params30:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode30) 
    jmp Lcont30
Lcode30:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+32
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont30:
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont31:
leave
    ret 
Lcont32:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+288], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+96]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 3
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length35
count_env_length35:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length35
    jmp count_env_length35
end_count_env_length35: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env35 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env35:
    cmp rsi, rcx
    je end_copy_old_env35 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env35

extent_first_env35:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env35:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params35:
    cmp rcx, rdx 
    je end_copy_params35 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params35
end_copy_params35:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode35) 
    jmp Lcont35
Lcode35:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length34
count_env_length34:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length34
    jmp count_env_length34
end_count_env_length34: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env34 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env34:
    cmp rsi, rcx
    je end_copy_old_env34 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env34

extent_first_env34:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env34:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params34:
    cmp rcx, rdx 
    je end_copy_params34 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params34
end_copy_params34:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode34) 
    jmp Lcont34
Lcode34:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil34

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list34:
    cmp rdi, rcx
    je end_generate_opt_list34 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list34
  end_generate_opt_list34:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start34
  put_nil34:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start34:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse33
push qword 12345678
mov rax, const_tbl+50
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit33
Lelse33:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit33:
leave
    ret 
Lcont34:
leave
    ret 
Lcont35:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+96], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length37
count_env_length37:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length37
    jmp count_env_length37
end_count_env_length37: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env37 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env37:
    cmp rsi, rcx
    je end_copy_old_env37 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env37

extent_first_env37:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env37:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params37:
    cmp rcx, rdx 
    je end_copy_params37 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params37
end_copy_params37:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode37) 
    jmp Lcont37
Lcode37:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse36
mov rax, const_tbl+2
jmp Lexit36
Lelse36:
mov rax, const_tbl+4
Lexit36:
leave
    ret 
Lcont37:
mov qword [fvar_tbl+296], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+16]
push rax
mov rax, qword [fvar_tbl+8]
push rax
push 2
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length40
count_env_length40:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length40
    jmp count_env_length40
end_count_env_length40: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env40 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env40:
    cmp rsi, rcx
    je end_copy_old_env40 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env40

extent_first_env40:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env40:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params40:
    cmp rcx, rdx 
    je end_copy_params40 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params40
end_copy_params40:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode40) 
    jmp Lcont40
Lcode40:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length39
count_env_length39:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length39
    jmp count_env_length39
end_count_env_length39: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env39 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env39:
    cmp rsi, rcx
    je end_copy_old_env39 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env39

extent_first_env39:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env39:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params39:
    cmp rcx, rdx 
    je end_copy_params39 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params39
end_copy_params39:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode39) 
    jmp Lcont39
Lcode39:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit38
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit38

Lexit38:
leave
    ret 
Lcont39:
leave
    ret 
Lcont40:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+304], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+136]
push rax
mov rax, qword [fvar_tbl+240]
push rax
push 2
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length42
count_env_length42:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length42
    jmp count_env_length42
end_count_env_length42: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env42 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env42:
    cmp rsi, rcx
    je end_copy_old_env42 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env42

extent_first_env42:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env42:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params42:
    cmp rcx, rdx 
    je end_copy_params42 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params42
end_copy_params42:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode42) 
    jmp Lcont42
Lcode42:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length41
count_env_length41:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length41
    jmp count_env_length41
end_count_env_length41: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env41 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env41:
    cmp rsi, rcx
    je end_copy_old_env41 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env41

extent_first_env41:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env41:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params41:
    cmp rcx, rdx 
    je end_copy_params41 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params41
end_copy_params41:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode41) 
    jmp Lcont41
Lcode41:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 0 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil41

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list41:
    cmp rdi, rcx
    je end_generate_opt_list41 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list41
  end_generate_opt_list41:
    mov rdx, 0 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start41
  put_nil41:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start41:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+41
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont41:
leave
    ret 
Lcont42:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+136], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+144]
push rax
mov rax, qword [fvar_tbl+240]
push rax
push 2
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length44
count_env_length44:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length44
    jmp count_env_length44
end_count_env_length44: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env44 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env44:
    cmp rsi, rcx
    je end_copy_old_env44 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env44

extent_first_env44:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env44:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params44:
    cmp rcx, rdx 
    je end_copy_params44 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params44
end_copy_params44:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode44) 
    jmp Lcont44
Lcode44:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length43
count_env_length43:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length43
    jmp count_env_length43
end_count_env_length43: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env43 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env43:
    cmp rsi, rcx
    je end_copy_old_env43 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env43

extent_first_env43:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env43:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params43:
    cmp rcx, rdx 
    je end_copy_params43 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params43
end_copy_params43:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode43) 
    jmp Lcont43
Lcode43:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 0 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil43

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list43:
    cmp rdi, rcx
    je end_generate_opt_list43 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list43
  end_generate_opt_list43:
    mov rdx, 0 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start43
  put_nil43:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start43:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+32
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont43:
leave
    ret 
Lcont44:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+144], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+136]
push rax
mov rax, qword [fvar_tbl+152]
push rax
mov rax, qword [fvar_tbl+224]
push rax
push 4
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length47
count_env_length47:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length47
    jmp count_env_length47
end_count_env_length47: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env47 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env47:
    cmp rsi, rcx
    je end_copy_old_env47 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env47

extent_first_env47:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env47:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params47:
    cmp rcx, rdx 
    je end_copy_params47 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params47
end_copy_params47:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode47) 
    jmp Lcont47
Lcode47:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length46
count_env_length46:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length46
    jmp count_env_length46
end_count_env_length46: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env46 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env46:
    cmp rsi, rcx
    je end_copy_old_env46 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env46

extent_first_env46:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env46:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params46:
    cmp rcx, rdx 
    je end_copy_params46 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params46
end_copy_params46:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode46) 
    jmp Lcont46
Lcode46:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil46

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list46:
    cmp rdi, rcx
    je end_generate_opt_list46 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list46
  end_generate_opt_list46:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start46
  put_nil46:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start46:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse45
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+41
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit45
Lelse45:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*2]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit45:
leave
    ret 
Lcont46:
leave
    ret 
Lcont47:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+152], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+144]
push rax
mov rax, qword [fvar_tbl+160]
push rax
mov rax, qword [fvar_tbl+224]
push rax
push 4
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length50
count_env_length50:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length50
    jmp count_env_length50
end_count_env_length50: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env50 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env50:
    cmp rsi, rcx
    je end_copy_old_env50 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env50

extent_first_env50:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env50:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params50:
    cmp rcx, rdx 
    je end_copy_params50 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params50
end_copy_params50:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode50) 
    jmp Lcont50
Lcode50:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length49
count_env_length49:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length49
    jmp count_env_length49
end_count_env_length49: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env49 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env49:
    cmp rsi, rcx
    je end_copy_old_env49 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env49

extent_first_env49:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env49:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params49:
    cmp rcx, rdx 
    je end_copy_params49 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params49
end_copy_params49:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode49) 
    jmp Lcont49
Lcode49:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil49

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list49:
    cmp rdi, rcx
    je end_generate_opt_list49 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list49
  end_generate_opt_list49:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start49
  put_nil49:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start49:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse48
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, const_tbl+32
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit48
Lelse48:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*2]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit48:
leave
    ret 
Lcont49:
leave
    ret 
Lcont50:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+160], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+224]
push rax
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+176]
push rax
push 5
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length55
count_env_length55:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length55
    jmp count_env_length55
end_count_env_length55: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env55 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env55:
    cmp rsi, rcx
    je end_copy_old_env55 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env55

extent_first_env55:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env55:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params55:
    cmp rcx, rdx 
    je end_copy_params55 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params55
end_copy_params55:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode55) 
    jmp Lcont55
Lcode55:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length54
count_env_length54:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length54
    jmp count_env_length54
end_count_env_length54: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env54 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env54:
    cmp rsi, rcx
    je end_copy_old_env54 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env54

extent_first_env54:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env54:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params54:
    cmp rcx, rdx 
    je end_copy_params54 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params54
end_copy_params54:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode54) 
    jmp Lcont54
Lcode54:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length53
count_env_length53:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length53
    jmp count_env_length53
end_count_env_length53: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env53 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env53:
    cmp rsi, rcx
    je end_copy_old_env53 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env53

extent_first_env53:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env53:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params53:
    cmp rcx, rdx 
    je end_copy_params53 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params53
end_copy_params53:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode53) 
    jmp Lcont53
Lcode53:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil53

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list53:
    cmp rdi, rcx
    je end_generate_opt_list53 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list53
  end_generate_opt_list53:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start53
  put_nil53:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start53:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse52
mov rax, const_tbl+4
jmp Lexit52
Lelse52:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse51
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
push rax
push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit51
Lelse51:
mov rax, const_tbl+2
Lexit51:
Lexit52:
leave
    ret 
Lcont53:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
leave
    ret 
Lcont54:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont55:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+176], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+168]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 4
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length61
count_env_length61:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length61
    jmp count_env_length61
end_count_env_length61: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env61 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env61:
    cmp rsi, rcx
    je end_copy_old_env61 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env61

extent_first_env61:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env61:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params61:
    cmp rcx, rdx 
    je end_copy_params61 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params61
end_copy_params61:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode61) 
    jmp Lcont61
Lcode61:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length60
count_env_length60:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length60
    jmp count_env_length60
end_count_env_length60: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env60 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env60:
    cmp rsi, rcx
    je end_copy_old_env60 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env60

extent_first_env60:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env60:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params60:
    cmp rcx, rdx 
    je end_copy_params60 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params60
end_copy_params60:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode60) 
    jmp Lcont60
Lcode60:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length58
count_env_length58:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length58
    jmp count_env_length58
end_count_env_length58: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env58 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env58:
    cmp rsi, rcx
    je end_copy_old_env58 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env58

extent_first_env58:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env58:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params58:
    cmp rcx, rdx 
    je end_copy_params58 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params58
end_copy_params58:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode58) 
    jmp Lcont58
Lcode58:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse57
mov rax, const_tbl+4
jmp Lexit57
Lelse57:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse56
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit56
Lelse56:
mov rax, const_tbl+2
Lexit56:
Lexit57:
leave
    ret 
Lcont58:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length59
count_env_length59:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length59
    jmp count_env_length59
end_count_env_length59: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env59 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env59:
    cmp rsi, rcx
    je end_copy_old_env59 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env59

extent_first_env59:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env59:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params59:
    cmp rcx, rdx 
    je end_copy_params59 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params59
end_copy_params59:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode59) 
    jmp Lcont59
Lcode59:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil59

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list59:
    cmp rdi, rcx
    je end_generate_opt_list59 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list59
  end_generate_opt_list59:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start59
  put_nil59:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start59:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont59:
leave
    ret 
Lcont60:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont61:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+168], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+296]
push rax
mov rax, qword [fvar_tbl+176]
push rax
mov rax, qword [fvar_tbl+168]
push rax
mov rax, qword [fvar_tbl+32]
push rax
push 6
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length68
count_env_length68:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length68
    jmp count_env_length68
end_count_env_length68: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env68 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env68:
    cmp rsi, rcx
    je end_copy_old_env68 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env68

extent_first_env68:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env68:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params68:
    cmp rcx, rdx 
    je end_copy_params68 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params68
end_copy_params68:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode68) 
    jmp Lcont68
Lcode68:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length67
count_env_length67:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length67
    jmp count_env_length67
end_count_env_length67: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env67 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env67:
    cmp rsi, rcx
    je end_copy_old_env67 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env67

extent_first_env67:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env67:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params67:
    cmp rcx, rdx 
    je end_copy_params67 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params67
end_copy_params67:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode67) 
    jmp Lcont67
Lcode67:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length65
count_env_length65:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length65
    jmp count_env_length65
end_count_env_length65: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env65 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env65:
    cmp rsi, rcx
    je end_copy_old_env65 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env65

extent_first_env65:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env65:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params65:
    cmp rcx, rdx 
    je end_copy_params65 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params65
end_copy_params65:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode65) 
    jmp Lcont65
Lcode65:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse64
mov rax, const_tbl+4
jmp Lexit64
Lelse64:
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit62
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit62

Lexit62:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse63
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*5]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
jmp Lexit63
Lelse63:
mov rax, const_tbl+2
Lexit63:
Lexit64:
leave
    ret 
Lcont65:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length66
count_env_length66:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length66
    jmp count_env_length66
end_count_env_length66: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env66 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env66:
    cmp rsi, rcx
    je end_copy_old_env66 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env66

extent_first_env66:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env66:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params66:
    cmp rcx, rdx 
    je end_copy_params66 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params66
end_copy_params66:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode66) 
    jmp Lcont66
Lcode66:
    mov rcx, [rsp + 2*8] ;; number of argumants
    mov rdx, 1 
    mov rsi, 2 
    add rsi, rcx ;;last argumant
    shl rsi, 3 ;;mul by 8
    add rsi ,rsp ;;rsi is the top the stack befor magic 
    sub rcx, rdx ;;number of iteration
    cmp rcx, 0 ;;empty opt
    je put_nil66

    mov rbx, qword [rsi]
    MAKE_PAIR(rax ,rbx ,SOB_NIL_ADDRESS)
    mov rdi, 1
    sub rsi, 8 ;;to go down by one argumant 
  generate_opt_list66:
    cmp rdi, rcx
    je end_generate_opt_list66 
    mov rbx, qword [rsi] ;;current argumant
    mov rdx, rax ;;ponter to previus pair
    MAKE_PAIR(rax ,rbx ,rdx)
    inc rdi
    sub rsi, 8 ;;to go down by one argumant 
    jmp generate_opt_list66
  end_generate_opt_list66:
    mov rdx, 1 
    mov rcx, 3 ;;until first args +1 for the new argument that we added
    add rcx, rdx ;;plus number of argumants
    shl rcx, 3 ;;multiply by 8
    add rcx, rsp ;;make it the pointer to the first optional arg
    mov qword [rcx], rax ;; list of optionals
    inc rdx ;;new number of args
    mov rcx, qword [rsp + 2*8] ;; previous number of args
    mov qword [rsp + 2*8], rdx ;; change number of argumant to be real number of argoumants
    ;;dest = (prev number of args - cur args) * 8 + rsp 
    mov rdi, rcx ;;prev number of args 
    sub rdi, rdx ;;curr
    shl rdi, 3 
    add rdi, rsp ;;dest
    ;;src = rsp
    mov rsi, rsp
    ;;size 
    add rdx, 3
    shl rdx, 3
    call memmove 
    mov rsp, rax 
    jmp body_start66
  put_nil66:
    add rsi, 8 ;; get to magic
    mov qword [rsi], SOB_NIL_ADDRESS
  body_start66:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont66:
leave
    ret 
Lcont67:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont68:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+312], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+176]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length70
count_env_length70:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length70
    jmp count_env_length70
end_count_env_length70: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env70 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env70:
    cmp rsi, rcx
    je end_copy_old_env70 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env70

extent_first_env70:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env70:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params70:
    cmp rcx, rdx 
    je end_copy_params70 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params70
end_copy_params70:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode70) 
    jmp Lcont70
Lcode70:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length69
count_env_length69:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length69
    jmp count_env_length69
end_count_env_length69: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env69 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env69:
    cmp rsi, rcx
    je end_copy_old_env69 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env69

extent_first_env69:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env69:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params69:
    cmp rcx, rdx 
    je end_copy_params69 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params69
end_copy_params69:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode69) 
    jmp Lcont69
Lcode69:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+41
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont69:
leave
    ret 
Lcont70:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+320], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+152]
push rax
mov rax, qword [fvar_tbl+168]
push rax
mov rax, qword [fvar_tbl+72]
push rax
mov rax, qword [fvar_tbl+80]
push rax
push 4
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length75
count_env_length75:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length75
    jmp count_env_length75
end_count_env_length75: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env75 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env75:
    cmp rsi, rcx
    je end_copy_old_env75 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env75

extent_first_env75:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env75:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params75:
    cmp rcx, rdx 
    je end_copy_params75 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params75
end_copy_params75:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode75) 
    jmp Lcont75
Lcode75:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length74
count_env_length74:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length74
    jmp count_env_length74
end_count_env_length74: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env74 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env74:
    cmp rsi, rcx
    je end_copy_old_env74 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env74

extent_first_env74:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env74:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params74:
    cmp rcx, rdx 
    je end_copy_params74 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params74
end_copy_params74:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode74) 
    jmp Lcont74
Lcode74:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length73
count_env_length73:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length73
    jmp count_env_length73
end_count_env_length73: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env73 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env73:
    cmp rsi, rcx
    je end_copy_old_env73 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env73

extent_first_env73:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env73:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params73:
    cmp rcx, rdx 
    je end_copy_params73 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params73
end_copy_params73:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode73) 
    jmp Lcont73
Lcode73:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length72
count_env_length72:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length72
    jmp count_env_length72
end_count_env_length72: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env72 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env72:
    cmp rsi, rcx
    je end_copy_old_env72 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env72

extent_first_env72:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env72:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params72:
    cmp rcx, rdx 
    je end_copy_params72 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params72
end_copy_params72:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode72) 
    jmp Lcont72
Lcode72:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+41
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse71
mov rax, qword [rbp + 8 * (4 + 1)]
jmp Lexit71
Lelse71:
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [fvar_tbl+200]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, const_tbl+32
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
Lexit71:
leave
    ret 
Lcont72:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
push qword 12345678
mov rax, const_tbl+1
push rax
push qword 12345678
mov rax, const_tbl+32
push rax
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont73:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont74:
leave
    ret 
Lcont75:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+328], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, qword [fvar_tbl+112]
push rax
mov rax, qword [fvar_tbl+192]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, qword [fvar_tbl+128]
push rax
mov rax, qword [fvar_tbl+48]
push rax
mov rax, qword [fvar_tbl+40]
push rax
mov rax, qword [fvar_tbl+24]
push rax
mov rax, qword [fvar_tbl+8]
push rax
mov rax, qword [fvar_tbl+16]
push rax
mov rax, qword [fvar_tbl+328]
push rax
mov rax, qword [fvar_tbl+176]
push rax
push 11
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length90
count_env_length90:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length90
    jmp count_env_length90
end_count_env_length90: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env90 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env90:
    cmp rsi, rcx
    je end_copy_old_env90 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env90

extent_first_env90:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env90:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params90:
    cmp rcx, rdx 
    je end_copy_params90 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params90
end_copy_params90:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode90) 
    jmp Lcont90
Lcode90:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, const_tbl+23
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length89
count_env_length89:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length89
    jmp count_env_length89
end_count_env_length89: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env89 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env89:
    cmp rsi, rcx
    je end_copy_old_env89 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env89

extent_first_env89:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env89:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params89:
    cmp rcx, rdx 
    je end_copy_params89 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params89
end_copy_params89:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode89) 
    jmp Lcont89
Lcode89:
    push rbp
    mov rbp, rsp 

mov rax, qword [rbp + 8 * (4 + 0)]
MALLOC rbx, 8
mov [rbx], rax
mov rax, rbx
mov qword [rbp + 8*(4+ 0)], rax
mov rax, SOB_VOID_ADDRESS

mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length88
count_env_length88:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length88
    jmp count_env_length88
end_count_env_length88: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env88 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env88:
    cmp rsi, rcx
    je end_copy_old_env88 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env88

extent_first_env88:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env88:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params88:
    cmp rcx, rdx 
    je end_copy_params88 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params88
end_copy_params88:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode88) 
    jmp Lcont88
Lcode88:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse77
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*2]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse76
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
jmp Lexit76
Lelse76:
mov rax, const_tbl+2
Lexit76:
jmp Lexit77
Lelse77:
mov rax, const_tbl+2
Lexit77:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse79
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*3]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse78
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
jmp Lexit78
Lelse78:
mov rax, const_tbl+2
Lexit78:
jmp Lexit79
Lelse79:
mov rax, const_tbl+2
Lexit79:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse82
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*4]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse81
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*8]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*8]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse80
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*9]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*9]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
jmp Lexit80
Lelse80:
mov rax, const_tbl+2
Lexit80:
jmp Lexit81
Lelse81:
mov rax, const_tbl+2
Lexit81:
jmp Lexit82
Lelse82:
mov rax, const_tbl+2
Lexit82:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*5]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse84
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*5]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse83
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*10]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*10]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
jmp Lexit83
Lelse83:
mov rax, const_tbl+2
Lexit83:
jmp Lexit84
Lelse84:
mov rax, const_tbl+2
Lexit84:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*6]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse86
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*6]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp rax, SOB_FALSE_ADDRESS
je Lelse85
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*1]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
mov rax, qword [rax]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
jmp Lexit85
Lelse85:
mov rax, const_tbl+2
Lexit85:
jmp Lexit86
Lelse86:
mov rax, const_tbl+2
Lexit86:
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 1)]
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*7]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
cmp rax, SOB_FALSE_ADDRESS 
jne Lexit87

Lexit87:
leave
    ret 
Lcont88:
push rax
mov rax, qword [rbp + 8 * (4 + 0)]
pop qword [rax] 
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]
mov rax, qword [rax]
leave
    ret 
Lcont89:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont90:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
mov qword [fvar_tbl+336], rax
mov rax, SOB_VOID_ADDRESS
	call write_sob_if_not_void

push qword 12345678
mov rax, const_tbl+2
push rax
push 1
push qword 12345678
mov rax, const_tbl+4
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length92
count_env_length92:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length92
    jmp count_env_length92
end_count_env_length92: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env92 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env92:
    cmp rsi, rcx
    je end_copy_old_env92 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env92

extent_first_env92:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env92:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params92:
    cmp rcx, rdx 
    je end_copy_params92 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params92
end_copy_params92:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode92) 
    jmp Lcont92
Lcode92:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length91
count_env_length91:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length91
    jmp count_env_length91
end_count_env_length91: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env91 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env91:
    cmp rsi, rcx
    je end_copy_old_env91 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env91

extent_first_env91:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env91:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params91:
    cmp rcx, rdx 
    je end_copy_params91 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params91
end_copy_params91:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode91) 
    jmp Lcont91
Lcode91:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont91:
leave
    ret 
Lcont92:
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length94
count_env_length94:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length94
    jmp count_env_length94
end_count_env_length94: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env94 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env94:
    cmp rsi, rcx
    je end_copy_old_env94 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env94

extent_first_env94:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env94:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params94:
    cmp rcx, rdx 
    je end_copy_params94 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params94
end_copy_params94:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode94) 
    jmp Lcont94
Lcode94:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length93
count_env_length93:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length93
    jmp count_env_length93
end_count_env_length93: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env93 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env93:
    cmp rsi, rcx
    je end_copy_old_env93 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env93

extent_first_env93:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env93:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params93:
    cmp rcx, rdx 
    je end_copy_params93 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params93
end_copy_params93:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode93) 
    jmp Lcont93
Lcode93:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont93:
leave
    ret 
Lcont94:
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length96
count_env_length96:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length96
    jmp count_env_length96
end_count_env_length96: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env96 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env96:
    cmp rsi, rcx
    je end_copy_old_env96 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env96

extent_first_env96:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env96:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params96:
    cmp rcx, rdx 
    je end_copy_params96 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params96
end_copy_params96:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode96) 
    jmp Lcont96
Lcode96:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length95
count_env_length95:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length95
    jmp count_env_length95
end_count_env_length95: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env95 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env95:
    cmp rsi, rcx
    je end_copy_old_env95 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env95

extent_first_env95:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env95:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params95:
    cmp rcx, rdx 
    je end_copy_params95 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params95
end_copy_params95:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode95) 
    jmp Lcont95
Lcode95:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont95:
leave
    ret 
Lcont96:
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length98
count_env_length98:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length98
    jmp count_env_length98
end_count_env_length98: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env98 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env98:
    cmp rsi, rcx
    je end_copy_old_env98 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env98

extent_first_env98:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env98:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params98:
    cmp rcx, rdx 
    je end_copy_params98 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params98
end_copy_params98:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode98) 
    jmp Lcont98
Lcode98:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length97
count_env_length97:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length97
    jmp count_env_length97
end_count_env_length97: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env97 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env97:
    cmp rsi, rcx
    je end_copy_old_env97 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env97

extent_first_env97:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env97:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params97:
    cmp rcx, rdx 
    je end_copy_params97 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params97
end_copy_params97:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode97) 
    jmp Lcont97
Lcode97:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont97:
leave
    ret 
Lcont98:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length107
count_env_length107:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length107
    jmp count_env_length107
end_count_env_length107: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env107 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env107:
    cmp rsi, rcx
    je end_copy_old_env107 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env107

extent_first_env107:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env107:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params107:
    cmp rcx, rdx 
    je end_copy_params107 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params107
end_copy_params107:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode107) 
    jmp Lcont107
Lcode107:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length106
count_env_length106:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length106
    jmp count_env_length106
end_count_env_length106: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env106 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env106:
    cmp rsi, rcx
    je end_copy_old_env106 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env106

extent_first_env106:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env106:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params106:
    cmp rcx, rdx 
    je end_copy_params106 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params106
end_copy_params106:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode106) 
    jmp Lcont106
Lcode106:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length100
count_env_length100:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length100
    jmp count_env_length100
end_count_env_length100: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env100 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env100:
    cmp rsi, rcx
    je end_copy_old_env100 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env100

extent_first_env100:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env100:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params100:
    cmp rcx, rdx 
    je end_copy_params100 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params100
end_copy_params100:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode100) 
    jmp Lcont100
Lcode100:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length99
count_env_length99:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length99
    jmp count_env_length99
end_count_env_length99: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env99 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env99:
    cmp rsi, rcx
    je end_copy_old_env99 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env99

extent_first_env99:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env99:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params99:
    cmp rcx, rdx 
    je end_copy_params99 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params99
end_copy_params99:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode99) 
    jmp Lcont99
Lcode99:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont99:
leave
    ret 
Lcont100:
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length105
count_env_length105:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length105
    jmp count_env_length105
end_count_env_length105: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env105 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env105:
    cmp rsi, rcx
    je end_copy_old_env105 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env105

extent_first_env105:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env105:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params105:
    cmp rcx, rdx 
    je end_copy_params105 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params105
end_copy_params105:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode105) 
    jmp Lcont105
Lcode105:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length104
count_env_length104:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length104
    jmp count_env_length104
end_count_env_length104: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env104 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env104:
    cmp rsi, rcx
    je end_copy_old_env104 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env104

extent_first_env104:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env104:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params104:
    cmp rcx, rdx 
    je end_copy_params104 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params104
end_copy_params104:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode104) 
    jmp Lcont104
Lcode104:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length103
count_env_length103:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length103
    jmp count_env_length103
end_count_env_length103: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env103 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env103:
    cmp rsi, rcx
    je end_copy_old_env103 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env103

extent_first_env103:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env103:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params103:
    cmp rcx, rdx 
    je end_copy_params103 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params103
end_copy_params103:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode103) 
    jmp Lcont103
Lcode103:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length102
count_env_length102:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length102
    jmp count_env_length102
end_count_env_length102: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env102 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env102:
    cmp rsi, rcx
    je end_copy_old_env102 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env102

extent_first_env102:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env102:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params102:
    cmp rcx, rdx 
    je end_copy_params102 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params102
end_copy_params102:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode102) 
    jmp Lcont102
Lcode102:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length101
count_env_length101:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length101
    jmp count_env_length101
end_count_env_length101: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env101 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env101:
    cmp rsi, rcx
    je end_copy_old_env101 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env101

extent_first_env101:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env101:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params101:
    cmp rcx, rdx 
    je end_copy_params101 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params101
end_copy_params101:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode101) 
    jmp Lcont101
Lcode101:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont101:
leave
    ret 
Lcont102:
leave
    ret 
Lcont103:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont104:
leave
    ret 
Lcont105:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont106:
leave
    ret 
Lcont107:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length116
count_env_length116:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length116
    jmp count_env_length116
end_count_env_length116: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env116 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env116:
    cmp rsi, rcx
    je end_copy_old_env116 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env116

extent_first_env116:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env116:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params116:
    cmp rcx, rdx 
    je end_copy_params116 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params116
end_copy_params116:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode116) 
    jmp Lcont116
Lcode116:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length115
count_env_length115:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length115
    jmp count_env_length115
end_count_env_length115: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env115 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env115:
    cmp rsi, rcx
    je end_copy_old_env115 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env115

extent_first_env115:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env115:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params115:
    cmp rcx, rdx 
    je end_copy_params115 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params115
end_copy_params115:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode115) 
    jmp Lcont115
Lcode115:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length109
count_env_length109:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length109
    jmp count_env_length109
end_count_env_length109: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env109 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env109:
    cmp rsi, rcx
    je end_copy_old_env109 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env109

extent_first_env109:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env109:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params109:
    cmp rcx, rdx 
    je end_copy_params109 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params109
end_copy_params109:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode109) 
    jmp Lcont109
Lcode109:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length108
count_env_length108:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length108
    jmp count_env_length108
end_count_env_length108: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env108 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env108:
    cmp rsi, rcx
    je end_copy_old_env108 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env108

extent_first_env108:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env108:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params108:
    cmp rcx, rdx 
    je end_copy_params108 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params108
end_copy_params108:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode108) 
    jmp Lcont108
Lcode108:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont108:
leave
    ret 
Lcont109:
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length114
count_env_length114:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length114
    jmp count_env_length114
end_count_env_length114: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env114 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env114:
    cmp rsi, rcx
    je end_copy_old_env114 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env114

extent_first_env114:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env114:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params114:
    cmp rcx, rdx 
    je end_copy_params114 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params114
end_copy_params114:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode114) 
    jmp Lcont114
Lcode114:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length113
count_env_length113:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length113
    jmp count_env_length113
end_count_env_length113: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env113 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env113:
    cmp rsi, rcx
    je end_copy_old_env113 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env113

extent_first_env113:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env113:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params113:
    cmp rcx, rdx 
    je end_copy_params113 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params113
end_copy_params113:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode113) 
    jmp Lcont113
Lcode113:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length112
count_env_length112:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length112
    jmp count_env_length112
end_count_env_length112: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env112 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env112:
    cmp rsi, rcx
    je end_copy_old_env112 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env112

extent_first_env112:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env112:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params112:
    cmp rcx, rdx 
    je end_copy_params112 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params112
end_copy_params112:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode112) 
    jmp Lcont112
Lcode112:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length111
count_env_length111:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length111
    jmp count_env_length111
end_count_env_length111: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env111 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env111:
    cmp rsi, rcx
    je end_copy_old_env111 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env111

extent_first_env111:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env111:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params111:
    cmp rcx, rdx 
    je end_copy_params111 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params111
end_copy_params111:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode111) 
    jmp Lcont111
Lcode111:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length110
count_env_length110:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length110
    jmp count_env_length110
end_count_env_length110: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env110 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env110:
    cmp rsi, rcx
    je end_copy_old_env110 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env110

extent_first_env110:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env110:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params110:
    cmp rcx, rdx 
    je end_copy_params110 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params110
end_copy_params110:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode110) 
    jmp Lcont110
Lcode110:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont110:
leave
    ret 
Lcont111:
leave
    ret 
Lcont112:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont113:
leave
    ret 
Lcont114:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont115:
leave
    ret 
Lcont116:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length118
count_env_length118:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length118
    jmp count_env_length118
end_count_env_length118: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env118 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env118:
    cmp rsi, rcx
    je end_copy_old_env118 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env118

extent_first_env118:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env118:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params118:
    cmp rcx, rdx 
    je end_copy_params118 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params118
end_copy_params118:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode118) 
    jmp Lcont118
Lcode118:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length117
count_env_length117:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length117
    jmp count_env_length117
end_count_env_length117: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env117 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env117:
    cmp rsi, rcx
    je end_copy_old_env117 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env117

extent_first_env117:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env117:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params117:
    cmp rcx, rdx 
    je end_copy_params117 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params117
end_copy_params117:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode117) 
    jmp Lcont117
Lcode117:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont117:
leave
    ret 
Lcont118:
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length152
count_env_length152:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length152
    jmp count_env_length152
end_count_env_length152: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env152 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env152:
    cmp rsi, rcx
    je end_copy_old_env152 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env152

extent_first_env152:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env152:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params152:
    cmp rcx, rdx 
    je end_copy_params152 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params152
end_copy_params152:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode152) 
    jmp Lcont152
Lcode152:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length119
count_env_length119:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length119
    jmp count_env_length119
end_count_env_length119: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env119 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env119:
    cmp rsi, rcx
    je end_copy_old_env119 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env119

extent_first_env119:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env119:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params119:
    cmp rcx, rdx 
    je end_copy_params119 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params119
end_copy_params119:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode119) 
    jmp Lcont119
Lcode119:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont119:
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length120
count_env_length120:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length120
    jmp count_env_length120
end_count_env_length120: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env120 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env120:
    cmp rsi, rcx
    je end_copy_old_env120 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env120

extent_first_env120:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env120:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params120:
    cmp rcx, rdx 
    je end_copy_params120 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params120
end_copy_params120:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode120) 
    jmp Lcont120
Lcode120:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont120:
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length123
count_env_length123:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length123
    jmp count_env_length123
end_count_env_length123: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env123 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env123:
    cmp rsi, rcx
    je end_copy_old_env123 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env123

extent_first_env123:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env123:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params123:
    cmp rcx, rdx 
    je end_copy_params123 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params123
end_copy_params123:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode123) 
    jmp Lcont123
Lcode123:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length122
count_env_length122:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length122
    jmp count_env_length122
end_count_env_length122: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env122 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env122:
    cmp rsi, rcx
    je end_copy_old_env122 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env122

extent_first_env122:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env122:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params122:
    cmp rcx, rdx 
    je end_copy_params122 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params122
end_copy_params122:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode122) 
    jmp Lcont122
Lcode122:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length121
count_env_length121:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length121
    jmp count_env_length121
end_count_env_length121: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env121 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env121:
    cmp rsi, rcx
    je end_copy_old_env121 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env121

extent_first_env121:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env121:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params121:
    cmp rcx, rdx 
    je end_copy_params121 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params121
end_copy_params121:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode121) 
    jmp Lcont121
Lcode121:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont121:
leave
    ret 
Lcont122:
leave
    ret 
Lcont123:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length148
count_env_length148:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length148
    jmp count_env_length148
end_count_env_length148: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env148 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env148:
    cmp rsi, rcx
    je end_copy_old_env148 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env148

extent_first_env148:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env148:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params148:
    cmp rcx, rdx 
    je end_copy_params148 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params148
end_copy_params148:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode148) 
    jmp Lcont148
Lcode148:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length126
count_env_length126:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length126
    jmp count_env_length126
end_count_env_length126: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env126 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env126:
    cmp rsi, rcx
    je end_copy_old_env126 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env126

extent_first_env126:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env126:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params126:
    cmp rcx, rdx 
    je end_copy_params126 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params126
end_copy_params126:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode126) 
    jmp Lcont126
Lcode126:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length125
count_env_length125:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length125
    jmp count_env_length125
end_count_env_length125: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env125 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env125:
    cmp rsi, rcx
    je end_copy_old_env125 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env125

extent_first_env125:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env125:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params125:
    cmp rcx, rdx 
    je end_copy_params125 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params125
end_copy_params125:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode125) 
    jmp Lcont125
Lcode125:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length124
count_env_length124:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length124
    jmp count_env_length124
end_count_env_length124: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env124 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env124:
    cmp rsi, rcx
    je end_copy_old_env124 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env124

extent_first_env124:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env124:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params124:
    cmp rcx, rdx 
    je end_copy_params124 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params124
end_copy_params124:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode124) 
    jmp Lcont124
Lcode124:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont124:
leave
    ret 
Lcont125:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont126:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length129
count_env_length129:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length129
    jmp count_env_length129
end_count_env_length129: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env129 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env129:
    cmp rsi, rcx
    je end_copy_old_env129 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env129

extent_first_env129:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env129:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params129:
    cmp rcx, rdx 
    je end_copy_params129 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params129
end_copy_params129:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode129) 
    jmp Lcont129
Lcode129:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length128
count_env_length128:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length128
    jmp count_env_length128
end_count_env_length128: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env128 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env128:
    cmp rsi, rcx
    je end_copy_old_env128 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env128

extent_first_env128:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env128:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params128:
    cmp rcx, rdx 
    je end_copy_params128 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params128
end_copy_params128:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode128) 
    jmp Lcont128
Lcode128:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length127
count_env_length127:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length127
    jmp count_env_length127
end_count_env_length127: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env127 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env127:
    cmp rsi, rcx
    je end_copy_old_env127 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env127

extent_first_env127:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env127:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params127:
    cmp rcx, rdx 
    je end_copy_params127 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params127
end_copy_params127:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode127) 
    jmp Lcont127
Lcode127:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont127:
leave
    ret 
Lcont128:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont129:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length138
count_env_length138:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length138
    jmp count_env_length138
end_count_env_length138: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env138 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env138:
    cmp rsi, rcx
    je end_copy_old_env138 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env138

extent_first_env138:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env138:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params138:
    cmp rcx, rdx 
    je end_copy_params138 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params138
end_copy_params138:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode138) 
    jmp Lcont138
Lcode138:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length137
count_env_length137:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length137
    jmp count_env_length137
end_count_env_length137: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env137 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env137:
    cmp rsi, rcx
    je end_copy_old_env137 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env137

extent_first_env137:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env137:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params137:
    cmp rcx, rdx 
    je end_copy_params137 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params137
end_copy_params137:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode137) 
    jmp Lcont137
Lcode137:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length131
count_env_length131:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length131
    jmp count_env_length131
end_count_env_length131: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env131 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env131:
    cmp rsi, rcx
    je end_copy_old_env131 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env131

extent_first_env131:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env131:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params131:
    cmp rcx, rdx 
    je end_copy_params131 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params131
end_copy_params131:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode131) 
    jmp Lcont131
Lcode131:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length130
count_env_length130:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length130
    jmp count_env_length130
end_count_env_length130: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env130 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env130:
    cmp rsi, rcx
    je end_copy_old_env130 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env130

extent_first_env130:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env130:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params130:
    cmp rcx, rdx 
    je end_copy_params130 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params130
end_copy_params130:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode130) 
    jmp Lcont130
Lcode130:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont130:
leave
    ret 
Lcont131:
push rax
push 1
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length136
count_env_length136:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length136
    jmp count_env_length136
end_count_env_length136: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env136 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env136:
    cmp rsi, rcx
    je end_copy_old_env136 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env136

extent_first_env136:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env136:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params136:
    cmp rcx, rdx 
    je end_copy_params136 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params136
end_copy_params136:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode136) 
    jmp Lcont136
Lcode136:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length135
count_env_length135:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length135
    jmp count_env_length135
end_count_env_length135: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env135 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env135:
    cmp rsi, rcx
    je end_copy_old_env135 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env135

extent_first_env135:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env135:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params135:
    cmp rcx, rdx 
    je end_copy_params135 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params135
end_copy_params135:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode135) 
    jmp Lcont135
Lcode135:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length134
count_env_length134:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length134
    jmp count_env_length134
end_count_env_length134: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env134 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env134:
    cmp rsi, rcx
    je end_copy_old_env134 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env134

extent_first_env134:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env134:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params134:
    cmp rcx, rdx 
    je end_copy_params134 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params134
end_copy_params134:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode134) 
    jmp Lcont134
Lcode134:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length133
count_env_length133:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length133
    jmp count_env_length133
end_count_env_length133: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env133 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env133:
    cmp rsi, rcx
    je end_copy_old_env133 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env133

extent_first_env133:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env133:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params133:
    cmp rcx, rdx 
    je end_copy_params133 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params133
end_copy_params133:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode133) 
    jmp Lcont133
Lcode133:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length132
count_env_length132:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length132
    jmp count_env_length132
end_count_env_length132: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env132 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env132:
    cmp rsi, rcx
    je end_copy_old_env132 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env132

extent_first_env132:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env132:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params132:
    cmp rcx, rdx 
    je end_copy_params132 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params132
end_copy_params132:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode132) 
    jmp Lcont132
Lcode132:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont132:
leave
    ret 
Lcont133:
leave
    ret 
Lcont134:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont135:
leave
    ret 
Lcont136:
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont137:
leave
    ret 
Lcont138:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length141
count_env_length141:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length141
    jmp count_env_length141
end_count_env_length141: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env141 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env141:
    cmp rsi, rcx
    je end_copy_old_env141 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env141

extent_first_env141:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env141:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params141:
    cmp rcx, rdx 
    je end_copy_params141 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params141
end_copy_params141:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode141) 
    jmp Lcont141
Lcode141:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length140
count_env_length140:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length140
    jmp count_env_length140
end_count_env_length140: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env140 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env140:
    cmp rsi, rcx
    je end_copy_old_env140 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env140

extent_first_env140:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env140:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params140:
    cmp rcx, rdx 
    je end_copy_params140 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params140
end_copy_params140:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode140) 
    jmp Lcont140
Lcode140:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length139
count_env_length139:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length139
    jmp count_env_length139
end_count_env_length139: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env139 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env139:
    cmp rsi, rcx
    je end_copy_old_env139 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env139

extent_first_env139:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env139:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params139:
    cmp rcx, rdx 
    je end_copy_params139 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params139
end_copy_params139:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode139) 
    jmp Lcont139
Lcode139:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont139:
leave
    ret 
Lcont140:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont141:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length144
count_env_length144:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length144
    jmp count_env_length144
end_count_env_length144: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env144 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env144:
    cmp rsi, rcx
    je end_copy_old_env144 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env144

extent_first_env144:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env144:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params144:
    cmp rcx, rdx 
    je end_copy_params144 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params144
end_copy_params144:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode144) 
    jmp Lcont144
Lcode144:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length143
count_env_length143:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length143
    jmp count_env_length143
end_count_env_length143: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env143 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env143:
    cmp rsi, rcx
    je end_copy_old_env143 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env143

extent_first_env143:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env143:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params143:
    cmp rcx, rdx 
    je end_copy_params143 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params143
end_copy_params143:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode143) 
    jmp Lcont143
Lcode143:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length142
count_env_length142:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length142
    jmp count_env_length142
end_count_env_length142: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env142 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env142:
    cmp rsi, rcx
    je end_copy_old_env142 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env142

extent_first_env142:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env142:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params142:
    cmp rcx, rdx 
    je end_copy_params142 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params142
end_copy_params142:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode142) 
    jmp Lcont142
Lcode142:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont142:
leave
    ret 
Lcont143:
leave
    ret 
Lcont144:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length147
count_env_length147:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length147
    jmp count_env_length147
end_count_env_length147: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env147 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env147:
    cmp rsi, rcx
    je end_copy_old_env147 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env147

extent_first_env147:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env147:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params147:
    cmp rcx, rdx 
    je end_copy_params147 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params147
end_copy_params147:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode147) 
    jmp Lcont147
Lcode147:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length146
count_env_length146:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length146
    jmp count_env_length146
end_count_env_length146: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env146 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env146:
    cmp rsi, rcx
    je end_copy_old_env146 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env146

extent_first_env146:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env146:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params146:
    cmp rcx, rdx 
    je end_copy_params146 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params146
end_copy_params146:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode146) 
    jmp Lcont146
Lcode146:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length145
count_env_length145:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length145
    jmp count_env_length145
end_count_env_length145: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env145 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env145:
    cmp rsi, rcx
    je end_copy_old_env145 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env145

extent_first_env145:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env145:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params145:
    cmp rcx, rdx 
    je end_copy_params145 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params145
end_copy_params145:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode145) 
    jmp Lcont145
Lcode145:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont145:
leave
    ret 
Lcont146:
leave
    ret 
Lcont147:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont148:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length151
count_env_length151:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length151
    jmp count_env_length151
end_count_env_length151: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env151 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env151:
    cmp rsi, rcx
    je end_copy_old_env151 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env151

extent_first_env151:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env151:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params151:
    cmp rcx, rdx 
    je end_copy_params151 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params151
end_copy_params151:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode151) 
    jmp Lcont151
Lcode151:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length150
count_env_length150:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length150
    jmp count_env_length150
end_count_env_length150: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env150 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env150:
    cmp rsi, rcx
    je end_copy_old_env150 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env150

extent_first_env150:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env150:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params150:
    cmp rcx, rdx 
    je end_copy_params150 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params150
end_copy_params150:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode150) 
    jmp Lcont150
Lcode150:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length149
count_env_length149:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length149
    jmp count_env_length149
end_count_env_length149: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env149 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env149:
    cmp rsi, rcx
    je end_copy_old_env149 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env149

extent_first_env149:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env149:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params149:
    cmp rcx, rdx 
    je end_copy_params149 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params149
end_copy_params149:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode149) 
    jmp Lcont149
Lcode149:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont149:
leave
    ret 
Lcont150:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont151:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont152:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length222
count_env_length222:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length222
    jmp count_env_length222
end_count_env_length222: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env222 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env222:
    cmp rsi, rcx
    je end_copy_old_env222 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env222

extent_first_env222:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env222:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params222:
    cmp rcx, rdx 
    je end_copy_params222 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params222
end_copy_params222:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode222) 
    jmp Lcont222
Lcode222:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length221
count_env_length221:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length221
    jmp count_env_length221
end_count_env_length221: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env221 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env221:
    cmp rsi, rcx
    je end_copy_old_env221 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env221

extent_first_env221:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env221:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params221:
    cmp rcx, rdx 
    je end_copy_params221 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params221
end_copy_params221:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode221) 
    jmp Lcont221
Lcode221:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length178
count_env_length178:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length178
    jmp count_env_length178
end_count_env_length178: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env178 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env178:
    cmp rsi, rcx
    je end_copy_old_env178 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env178

extent_first_env178:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env178:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params178:
    cmp rcx, rdx 
    je end_copy_params178 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params178
end_copy_params178:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode178) 
    jmp Lcont178
Lcode178:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length177
count_env_length177:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length177
    jmp count_env_length177
end_count_env_length177: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env177 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env177:
    cmp rsi, rcx
    je end_copy_old_env177 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env177

extent_first_env177:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env177:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params177:
    cmp rcx, rdx 
    je end_copy_params177 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params177
end_copy_params177:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode177) 
    jmp Lcont177
Lcode177:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length176
count_env_length176:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length176
    jmp count_env_length176
end_count_env_length176: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env176 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env176:
    cmp rsi, rcx
    je end_copy_old_env176 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env176

extent_first_env176:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env176:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params176:
    cmp rcx, rdx 
    je end_copy_params176 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params176
end_copy_params176:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode176) 
    jmp Lcont176
Lcode176:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length154
count_env_length154:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length154
    jmp count_env_length154
end_count_env_length154: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env154 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env154:
    cmp rsi, rcx
    je end_copy_old_env154 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env154

extent_first_env154:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env154:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params154:
    cmp rcx, rdx 
    je end_copy_params154 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params154
end_copy_params154:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode154) 
    jmp Lcont154
Lcode154:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length153
count_env_length153:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length153
    jmp count_env_length153
end_count_env_length153: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env153 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env153:
    cmp rsi, rcx
    je end_copy_old_env153 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env153

extent_first_env153:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env153:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params153:
    cmp rcx, rdx 
    je end_copy_params153 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params153
end_copy_params153:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode153) 
    jmp Lcont153
Lcode153:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont153:
leave
    ret 
Lcont154:
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length156
count_env_length156:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length156
    jmp count_env_length156
end_count_env_length156: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env156 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env156:
    cmp rsi, rcx
    je end_copy_old_env156 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env156

extent_first_env156:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env156:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params156:
    cmp rcx, rdx 
    je end_copy_params156 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params156
end_copy_params156:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode156) 
    jmp Lcont156
Lcode156:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length155
count_env_length155:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length155
    jmp count_env_length155
end_count_env_length155: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env155 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env155:
    cmp rsi, rcx
    je end_copy_old_env155 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env155

extent_first_env155:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env155:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params155:
    cmp rcx, rdx 
    je end_copy_params155 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params155
end_copy_params155:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode155) 
    jmp Lcont155
Lcode155:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont155:
leave
    ret 
Lcont156:
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length159
count_env_length159:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length159
    jmp count_env_length159
end_count_env_length159: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env159 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env159:
    cmp rsi, rcx
    je end_copy_old_env159 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env159

extent_first_env159:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env159:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params159:
    cmp rcx, rdx 
    je end_copy_params159 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params159
end_copy_params159:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode159) 
    jmp Lcont159
Lcode159:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length158
count_env_length158:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length158
    jmp count_env_length158
end_count_env_length158: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env158 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env158:
    cmp rsi, rcx
    je end_copy_old_env158 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env158

extent_first_env158:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env158:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params158:
    cmp rcx, rdx 
    je end_copy_params158 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params158
end_copy_params158:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode158) 
    jmp Lcont158
Lcode158:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length157
count_env_length157:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length157
    jmp count_env_length157
end_count_env_length157: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env157 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env157:
    cmp rsi, rcx
    je end_copy_old_env157 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env157

extent_first_env157:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env157:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params157:
    cmp rcx, rdx 
    je end_copy_params157 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params157
end_copy_params157:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode157) 
    jmp Lcont157
Lcode157:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont157:
leave
    ret 
Lcont158:
leave
    ret 
Lcont159:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length172
count_env_length172:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length172
    jmp count_env_length172
end_count_env_length172: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env172 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env172:
    cmp rsi, rcx
    je end_copy_old_env172 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env172

extent_first_env172:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env172:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params172:
    cmp rcx, rdx 
    je end_copy_params172 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params172
end_copy_params172:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode172) 
    jmp Lcont172
Lcode172:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length162
count_env_length162:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length162
    jmp count_env_length162
end_count_env_length162: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env162 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env162:
    cmp rsi, rcx
    je end_copy_old_env162 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env162

extent_first_env162:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env162:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params162:
    cmp rcx, rdx 
    je end_copy_params162 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params162
end_copy_params162:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode162) 
    jmp Lcont162
Lcode162:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length161
count_env_length161:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length161
    jmp count_env_length161
end_count_env_length161: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env161 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env161:
    cmp rsi, rcx
    je end_copy_old_env161 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env161

extent_first_env161:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env161:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params161:
    cmp rcx, rdx 
    je end_copy_params161 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params161
end_copy_params161:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode161) 
    jmp Lcont161
Lcode161:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length160
count_env_length160:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length160
    jmp count_env_length160
end_count_env_length160: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env160 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env160:
    cmp rsi, rcx
    je end_copy_old_env160 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env160

extent_first_env160:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env160:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params160:
    cmp rcx, rdx 
    je end_copy_params160 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params160
end_copy_params160:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode160) 
    jmp Lcont160
Lcode160:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont160:
leave
    ret 
Lcont161:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont162:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length165
count_env_length165:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length165
    jmp count_env_length165
end_count_env_length165: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env165 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env165:
    cmp rsi, rcx
    je end_copy_old_env165 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env165

extent_first_env165:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env165:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params165:
    cmp rcx, rdx 
    je end_copy_params165 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params165
end_copy_params165:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode165) 
    jmp Lcont165
Lcode165:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length164
count_env_length164:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length164
    jmp count_env_length164
end_count_env_length164: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env164 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env164:
    cmp rsi, rcx
    je end_copy_old_env164 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env164

extent_first_env164:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env164:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params164:
    cmp rcx, rdx 
    je end_copy_params164 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params164
end_copy_params164:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode164) 
    jmp Lcont164
Lcode164:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length163
count_env_length163:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length163
    jmp count_env_length163
end_count_env_length163: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env163 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env163:
    cmp rsi, rcx
    je end_copy_old_env163 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env163

extent_first_env163:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env163:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params163:
    cmp rcx, rdx 
    je end_copy_params163 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params163
end_copy_params163:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode163) 
    jmp Lcont163
Lcode163:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont163:
leave
    ret 
Lcont164:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont165:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length168
count_env_length168:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length168
    jmp count_env_length168
end_count_env_length168: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env168 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env168:
    cmp rsi, rcx
    je end_copy_old_env168 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env168

extent_first_env168:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env168:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params168:
    cmp rcx, rdx 
    je end_copy_params168 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params168
end_copy_params168:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode168) 
    jmp Lcont168
Lcode168:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length167
count_env_length167:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length167
    jmp count_env_length167
end_count_env_length167: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env167 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env167:
    cmp rsi, rcx
    je end_copy_old_env167 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env167

extent_first_env167:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env167:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params167:
    cmp rcx, rdx 
    je end_copy_params167 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params167
end_copy_params167:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode167) 
    jmp Lcont167
Lcode167:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length166
count_env_length166:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length166
    jmp count_env_length166
end_count_env_length166: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env166 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env166:
    cmp rsi, rcx
    je end_copy_old_env166 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env166

extent_first_env166:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env166:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params166:
    cmp rcx, rdx 
    je end_copy_params166 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params166
end_copy_params166:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode166) 
    jmp Lcont166
Lcode166:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont166:
leave
    ret 
Lcont167:
leave
    ret 
Lcont168:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length171
count_env_length171:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length171
    jmp count_env_length171
end_count_env_length171: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env171 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env171:
    cmp rsi, rcx
    je end_copy_old_env171 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env171

extent_first_env171:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env171:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params171:
    cmp rcx, rdx 
    je end_copy_params171 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params171
end_copy_params171:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode171) 
    jmp Lcont171
Lcode171:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length170
count_env_length170:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length170
    jmp count_env_length170
end_count_env_length170: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env170 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env170:
    cmp rsi, rcx
    je end_copy_old_env170 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env170

extent_first_env170:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env170:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params170:
    cmp rcx, rdx 
    je end_copy_params170 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params170
end_copy_params170:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode170) 
    jmp Lcont170
Lcode170:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length169
count_env_length169:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length169
    jmp count_env_length169
end_count_env_length169: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env169 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env169:
    cmp rsi, rcx
    je end_copy_old_env169 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env169

extent_first_env169:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env169:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params169:
    cmp rcx, rdx 
    je end_copy_params169 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params169
end_copy_params169:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode169) 
    jmp Lcont169
Lcode169:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont169:
leave
    ret 
Lcont170:
leave
    ret 
Lcont171:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont172:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length175
count_env_length175:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length175
    jmp count_env_length175
end_count_env_length175: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env175 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env175:
    cmp rsi, rcx
    je end_copy_old_env175 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env175

extent_first_env175:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env175:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params175:
    cmp rcx, rdx 
    je end_copy_params175 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params175
end_copy_params175:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode175) 
    jmp Lcont175
Lcode175:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length174
count_env_length174:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length174
    jmp count_env_length174
end_count_env_length174: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env174 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env174:
    cmp rsi, rcx
    je end_copy_old_env174 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env174

extent_first_env174:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env174:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params174:
    cmp rcx, rdx 
    je end_copy_params174 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params174
end_copy_params174:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode174) 
    jmp Lcont174
Lcode174:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length173
count_env_length173:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length173
    jmp count_env_length173
end_count_env_length173: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env173 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env173:
    cmp rsi, rcx
    je end_copy_old_env173 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env173

extent_first_env173:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env173:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params173:
    cmp rcx, rdx 
    je end_copy_params173 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params173
end_copy_params173:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode173) 
    jmp Lcont173
Lcode173:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont173:
leave
    ret 
Lcont174:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont175:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont176:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont177:
leave
    ret 
Lcont178:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length184
count_env_length184:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length184
    jmp count_env_length184
end_count_env_length184: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env184 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env184:
    cmp rsi, rcx
    je end_copy_old_env184 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env184

extent_first_env184:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env184:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params184:
    cmp rcx, rdx 
    je end_copy_params184 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params184
end_copy_params184:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode184) 
    jmp Lcont184
Lcode184:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length180
count_env_length180:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length180
    jmp count_env_length180
end_count_env_length180: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env180 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env180:
    cmp rsi, rcx
    je end_copy_old_env180 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env180

extent_first_env180:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env180:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params180:
    cmp rcx, rdx 
    je end_copy_params180 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params180
end_copy_params180:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode180) 
    jmp Lcont180
Lcode180:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length179
count_env_length179:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length179
    jmp count_env_length179
end_count_env_length179: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env179 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env179:
    cmp rsi, rcx
    je end_copy_old_env179 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env179

extent_first_env179:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env179:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params179:
    cmp rcx, rdx 
    je end_copy_params179 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params179
end_copy_params179:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode179) 
    jmp Lcont179
Lcode179:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont179:
leave
    ret 
Lcont180:
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length183
count_env_length183:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length183
    jmp count_env_length183
end_count_env_length183: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env183 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env183:
    cmp rsi, rcx
    je end_copy_old_env183 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env183

extent_first_env183:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env183:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params183:
    cmp rcx, rdx 
    je end_copy_params183 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params183
end_copy_params183:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode183) 
    jmp Lcont183
Lcode183:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length182
count_env_length182:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length182
    jmp count_env_length182
end_count_env_length182: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env182 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env182:
    cmp rsi, rcx
    je end_copy_old_env182 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env182

extent_first_env182:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env182:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params182:
    cmp rcx, rdx 
    je end_copy_params182 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params182
end_copy_params182:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode182) 
    jmp Lcont182
Lcode182:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length181
count_env_length181:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length181
    jmp count_env_length181
end_count_env_length181: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env181 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env181:
    cmp rsi, rcx
    je end_copy_old_env181 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env181

extent_first_env181:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env181:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params181:
    cmp rcx, rdx 
    je end_copy_params181 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params181
end_copy_params181:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode181) 
    jmp Lcont181
Lcode181:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont181:
leave
    ret 
Lcont182:
leave
    ret 
Lcont183:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont184:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length210
count_env_length210:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length210
    jmp count_env_length210
end_count_env_length210: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env210 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env210:
    cmp rsi, rcx
    je end_copy_old_env210 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env210

extent_first_env210:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env210:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params210:
    cmp rcx, rdx 
    je end_copy_params210 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params210
end_copy_params210:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode210) 
    jmp Lcont210
Lcode210:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length209
count_env_length209:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length209
    jmp count_env_length209
end_count_env_length209: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env209 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env209:
    cmp rsi, rcx
    je end_copy_old_env209 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env209

extent_first_env209:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env209:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params209:
    cmp rcx, rdx 
    je end_copy_params209 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params209
end_copy_params209:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode209) 
    jmp Lcont209
Lcode209:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length208
count_env_length208:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length208
    jmp count_env_length208
end_count_env_length208: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env208 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env208:
    cmp rsi, rcx
    je end_copy_old_env208 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env208

extent_first_env208:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env208:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params208:
    cmp rcx, rdx 
    je end_copy_params208 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params208
end_copy_params208:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode208) 
    jmp Lcont208
Lcode208:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length186
count_env_length186:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length186
    jmp count_env_length186
end_count_env_length186: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env186 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env186:
    cmp rsi, rcx
    je end_copy_old_env186 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env186

extent_first_env186:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env186:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params186:
    cmp rcx, rdx 
    je end_copy_params186 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params186
end_copy_params186:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode186) 
    jmp Lcont186
Lcode186:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length185
count_env_length185:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length185
    jmp count_env_length185
end_count_env_length185: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env185 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env185:
    cmp rsi, rcx
    je end_copy_old_env185 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env185

extent_first_env185:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env185:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params185:
    cmp rcx, rdx 
    je end_copy_params185 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params185
end_copy_params185:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode185) 
    jmp Lcont185
Lcode185:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont185:
leave
    ret 
Lcont186:
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length188
count_env_length188:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length188
    jmp count_env_length188
end_count_env_length188: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env188 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env188:
    cmp rsi, rcx
    je end_copy_old_env188 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env188

extent_first_env188:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env188:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params188:
    cmp rcx, rdx 
    je end_copy_params188 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params188
end_copy_params188:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode188) 
    jmp Lcont188
Lcode188:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length187
count_env_length187:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length187
    jmp count_env_length187
end_count_env_length187: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env187 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env187:
    cmp rsi, rcx
    je end_copy_old_env187 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env187

extent_first_env187:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env187:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params187:
    cmp rcx, rdx 
    je end_copy_params187 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params187
end_copy_params187:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode187) 
    jmp Lcont187
Lcode187:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont187:
leave
    ret 
Lcont188:
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length191
count_env_length191:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length191
    jmp count_env_length191
end_count_env_length191: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env191 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env191:
    cmp rsi, rcx
    je end_copy_old_env191 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env191

extent_first_env191:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env191:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params191:
    cmp rcx, rdx 
    je end_copy_params191 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params191
end_copy_params191:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode191) 
    jmp Lcont191
Lcode191:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length190
count_env_length190:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length190
    jmp count_env_length190
end_count_env_length190: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env190 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env190:
    cmp rsi, rcx
    je end_copy_old_env190 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env190

extent_first_env190:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env190:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params190:
    cmp rcx, rdx 
    je end_copy_params190 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params190
end_copy_params190:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode190) 
    jmp Lcont190
Lcode190:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length189
count_env_length189:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length189
    jmp count_env_length189
end_count_env_length189: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env189 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env189:
    cmp rsi, rcx
    je end_copy_old_env189 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env189

extent_first_env189:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env189:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params189:
    cmp rcx, rdx 
    je end_copy_params189 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params189
end_copy_params189:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode189) 
    jmp Lcont189
Lcode189:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont189:
leave
    ret 
Lcont190:
leave
    ret 
Lcont191:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length204
count_env_length204:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length204
    jmp count_env_length204
end_count_env_length204: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env204 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env204:
    cmp rsi, rcx
    je end_copy_old_env204 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env204

extent_first_env204:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env204:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params204:
    cmp rcx, rdx 
    je end_copy_params204 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params204
end_copy_params204:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode204) 
    jmp Lcont204
Lcode204:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length194
count_env_length194:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length194
    jmp count_env_length194
end_count_env_length194: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env194 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env194:
    cmp rsi, rcx
    je end_copy_old_env194 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env194

extent_first_env194:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env194:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params194:
    cmp rcx, rdx 
    je end_copy_params194 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params194
end_copy_params194:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode194) 
    jmp Lcont194
Lcode194:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length193
count_env_length193:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length193
    jmp count_env_length193
end_count_env_length193: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env193 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env193:
    cmp rsi, rcx
    je end_copy_old_env193 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env193

extent_first_env193:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env193:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params193:
    cmp rcx, rdx 
    je end_copy_params193 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params193
end_copy_params193:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode193) 
    jmp Lcont193
Lcode193:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length192
count_env_length192:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length192
    jmp count_env_length192
end_count_env_length192: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env192 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env192:
    cmp rsi, rcx
    je end_copy_old_env192 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env192

extent_first_env192:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env192:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params192:
    cmp rcx, rdx 
    je end_copy_params192 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params192
end_copy_params192:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode192) 
    jmp Lcont192
Lcode192:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont192:
leave
    ret 
Lcont193:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont194:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
push qword 12345678
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length197
count_env_length197:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length197
    jmp count_env_length197
end_count_env_length197: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env197 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env197:
    cmp rsi, rcx
    je end_copy_old_env197 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env197

extent_first_env197:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env197:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params197:
    cmp rcx, rdx 
    je end_copy_params197 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params197
end_copy_params197:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode197) 
    jmp Lcont197
Lcode197:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length196
count_env_length196:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length196
    jmp count_env_length196
end_count_env_length196: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env196 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env196:
    cmp rsi, rcx
    je end_copy_old_env196 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env196

extent_first_env196:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env196:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params196:
    cmp rcx, rdx 
    je end_copy_params196 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params196
end_copy_params196:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode196) 
    jmp Lcont196
Lcode196:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length195
count_env_length195:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length195
    jmp count_env_length195
end_count_env_length195: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env195 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env195:
    cmp rsi, rcx
    je end_copy_old_env195 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env195

extent_first_env195:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env195:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params195:
    cmp rcx, rdx 
    je end_copy_params195 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params195
end_copy_params195:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode195) 
    jmp Lcont195
Lcode195:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont195:
leave
    ret 
Lcont196:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont197:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length200
count_env_length200:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length200
    jmp count_env_length200
end_count_env_length200: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env200 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env200:
    cmp rsi, rcx
    je end_copy_old_env200 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env200

extent_first_env200:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env200:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params200:
    cmp rcx, rdx 
    je end_copy_params200 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params200
end_copy_params200:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode200) 
    jmp Lcont200
Lcode200:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length199
count_env_length199:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length199
    jmp count_env_length199
end_count_env_length199: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env199 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env199:
    cmp rsi, rcx
    je end_copy_old_env199 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env199

extent_first_env199:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env199:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params199:
    cmp rcx, rdx 
    je end_copy_params199 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params199
end_copy_params199:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode199) 
    jmp Lcont199
Lcode199:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length198
count_env_length198:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length198
    jmp count_env_length198
end_count_env_length198: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env198 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env198:
    cmp rsi, rcx
    je end_copy_old_env198 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env198

extent_first_env198:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env198:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params198:
    cmp rcx, rdx 
    je end_copy_params198 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params198
end_copy_params198:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode198) 
    jmp Lcont198
Lcode198:
    push rbp
    mov rbp, rsp 
push qword 12345678
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont198:
leave
    ret 
Lcont199:
leave
    ret 
Lcont200:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length203
count_env_length203:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length203
    jmp count_env_length203
end_count_env_length203: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env203 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env203:
    cmp rsi, rcx
    je end_copy_old_env203 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env203

extent_first_env203:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env203:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params203:
    cmp rcx, rdx 
    je end_copy_params203 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params203
end_copy_params203:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode203) 
    jmp Lcont203
Lcode203:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length202
count_env_length202:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length202
    jmp count_env_length202
end_count_env_length202: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env202 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env202:
    cmp rsi, rcx
    je end_copy_old_env202 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env202

extent_first_env202:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env202:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params202:
    cmp rcx, rdx 
    je end_copy_params202 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params202
end_copy_params202:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode202) 
    jmp Lcont202
Lcode202:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length201
count_env_length201:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length201
    jmp count_env_length201
end_count_env_length201: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env201 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env201:
    cmp rsi, rcx
    je end_copy_old_env201 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env201

extent_first_env201:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env201:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params201:
    cmp rcx, rdx 
    je end_copy_params201 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params201
end_copy_params201:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode201) 
    jmp Lcont201
Lcode201:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1] 
mov rax, qword [rax + 8*0]
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont201:
leave
    ret 
Lcont202:
leave
    ret 
Lcont203:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont204:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length207
count_env_length207:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length207
    jmp count_env_length207
end_count_env_length207: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env207 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env207:
    cmp rsi, rcx
    je end_copy_old_env207 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env207

extent_first_env207:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env207:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params207:
    cmp rcx, rdx 
    je end_copy_params207 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params207
end_copy_params207:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode207) 
    jmp Lcont207
Lcode207:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length206
count_env_length206:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length206
    jmp count_env_length206
end_count_env_length206: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env206 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env206:
    cmp rsi, rcx
    je end_copy_old_env206 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env206

extent_first_env206:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env206:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params206:
    cmp rcx, rdx 
    je end_copy_params206 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params206
end_copy_params206:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode206) 
    jmp Lcont206
Lcode206:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length205
count_env_length205:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length205
    jmp count_env_length205
end_count_env_length205: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env205 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env205:
    cmp rsi, rcx
    je end_copy_old_env205 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env205

extent_first_env205:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env205:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params205:
    cmp rcx, rdx 
    je end_copy_params205 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params205
end_copy_params205:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode205) 
    jmp Lcont205
Lcode205:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont205:
leave
    ret 
Lcont206:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont207:
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont208:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont209:
leave
    ret 
Lcont210:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length216
count_env_length216:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length216
    jmp count_env_length216
end_count_env_length216: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env216 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env216:
    cmp rsi, rcx
    je end_copy_old_env216 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env216

extent_first_env216:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env216:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params216:
    cmp rcx, rdx 
    je end_copy_params216 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params216
end_copy_params216:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode216) 
    jmp Lcont216
Lcode216:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length212
count_env_length212:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length212
    jmp count_env_length212
end_count_env_length212: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env212 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env212:
    cmp rsi, rcx
    je end_copy_old_env212 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env212

extent_first_env212:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env212:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params212:
    cmp rcx, rdx 
    je end_copy_params212 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params212
end_copy_params212:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode212) 
    jmp Lcont212
Lcode212:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length211
count_env_length211:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length211
    jmp count_env_length211
end_count_env_length211: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env211 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env211:
    cmp rsi, rcx
    je end_copy_old_env211 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env211

extent_first_env211:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env211:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params211:
    cmp rcx, rdx 
    je end_copy_params211 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params211
end_copy_params211:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode211) 
    jmp Lcont211
Lcode211:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
leave
    ret 
Lcont211:
leave
    ret 
Lcont212:
push rax
push 1
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length215
count_env_length215:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length215
    jmp count_env_length215
end_count_env_length215: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env215 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env215:
    cmp rsi, rcx
    je end_copy_old_env215 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env215

extent_first_env215:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env215:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params215:
    cmp rcx, rdx 
    je end_copy_params215 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params215
end_copy_params215:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode215) 
    jmp Lcont215
Lcode215:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length214
count_env_length214:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length214
    jmp count_env_length214
end_count_env_length214: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env214 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env214:
    cmp rsi, rcx
    je end_copy_old_env214 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env214

extent_first_env214:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env214:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params214:
    cmp rcx, rdx 
    je end_copy_params214 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params214
end_copy_params214:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode214) 
    jmp Lcont214
Lcode214:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length213
count_env_length213:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length213
    jmp count_env_length213
end_count_env_length213: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env213 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env213:
    cmp rsi, rcx
    je end_copy_old_env213 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env213

extent_first_env213:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env213:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params213:
    cmp rcx, rdx 
    je end_copy_params213 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params213
end_copy_params213:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode213) 
    jmp Lcont213
Lcode213:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont213:
leave
    ret 
Lcont214:
leave
    ret 
Lcont215:
push rax
push 1
mov rax, qword [rbp + 8 * (4 + 0)]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont216:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
push rax
push 1
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length220
count_env_length220:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length220
    jmp count_env_length220
end_count_env_length220: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env220 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env220:
    cmp rsi, rcx
    je end_copy_old_env220 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env220

extent_first_env220:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env220:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params220:
    cmp rcx, rdx 
    je end_copy_params220 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params220
end_copy_params220:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode220) 
    jmp Lcont220
Lcode220:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length219
count_env_length219:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length219
    jmp count_env_length219
end_count_env_length219: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env219 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env219:
    cmp rsi, rcx
    je end_copy_old_env219 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env219

extent_first_env219:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env219:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params219:
    cmp rcx, rdx 
    je end_copy_params219 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params219
end_copy_params219:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode219) 
    jmp Lcont219
Lcode219:
    push rbp
    mov rbp, rsp 
push qword 12345678
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length218
count_env_length218:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length218
    jmp count_env_length218
end_count_env_length218: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env218 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env218:
    cmp rsi, rcx
    je end_copy_old_env218 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env218

extent_first_env218:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env218:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params218:
    cmp rcx, rdx 
    je end_copy_params218 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params218
end_copy_params218:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode218) 
    jmp Lcont218
Lcode218:
    push rbp
    mov rbp, rsp 
mov rbx, [rbp + 8*2] ;;rbx = address of env
  mov rcx, 1 ;;counter for size of env
  cmp qword rbx, SOB_NIL_ADDRESS ;;just for the first env 
  je end_count_env_length217
count_env_length217:
    add rcx, 1
    add rbx, 8 
    cmp qword [rbx], SOB_NIL_ADDRESS
    je end_count_env_length217
    jmp count_env_length217
end_count_env_length217: 
    push rcx
    add rcx,1 ;;size of extent env 
    shl rcx, 3 ;;mul rcx*8
    MALLOC rax, rcx 
    pop rcx ;;old env size 
    mov rbx, [rbp + 8*2] ;;rbx = address of old env 
    ;;extent first env
    cmp rcx, 1
    je extent_first_env217 
;;rbx is oldenv adrees and rax is extenvadrees
    mov rsi, 0 ;;i
    mov rdi, 1 ;;j
copy_old_env217:
    cmp rsi, rcx
    je end_copy_old_env217 
    mov rdx, [rbx + 8*rsi] ;;Env[i]
    mov [rax + 8*rdi], rdx ;;ExtEnv[j] = Env[i]
    inc rsi
    inc rdi 
    jmp copy_old_env217

extent_first_env217:
    mov qword [rax+8], SOB_NIL_ADDRESS

end_copy_old_env217:
    mov rdx, [rbp + 8*3]
    push rax
    push rdx 
    shl rdx, 3 ;;mul rdx*8
    MALLOC rbx, rdx ;;rbx is address of ExtEnv[0]
    pop rdx ;;number of params 
    pop rax ;;address of ExtEnv
    mov [rax], rbx  ;;put ExtEnv[0] address in ExtEnv Vector 
;;rbx is the pointer to the extenv[0] and rdx number of params 
    mov rcx,0
copy_params217:
    cmp rcx, rdx 
    je end_copy_params217 
    mov rsi, rcx 
    shl rsi, 3 ;;for param number rcx  = mul rsi*8
    add rsi, 4*8 ;;for the zeroth param
    add rsi, rbp 
    ;;[rbp + 4*8 + rcx*8]
    mov rsi, [rsi]
    mov [rbx+rcx*8], rsi 
    inc rcx 
    jmp copy_params217
end_copy_params217:
    mov rbx, rax 
    MAKE_CLOSURE(rax, rbx ,Lcode217) 
    jmp Lcont217
Lcode217:
    push rbp
    mov rbp, rsp 
mov rax, qword [rbp + 8 * (4 + 0)]
leave
    ret 
Lcont217:
leave
    ret 
Lcont218:
push rax
push 1
push qword 12345678
mov rax, qword [rbp + 8 * (4 + 0)]
push rax
push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0] 
mov rax, qword [rax + 8*0]
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont219:
leave
    ret 
Lcont220:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

                                 jne L_total_exit
                                 CLOSURE_ENV rbx, rax
                                 push rbx ;;push env 
                                 push qword [rbp + 8 * 1] ; old ret addr
                                 ;;fix the stack 
                                 push rax ;;address of closure 
                                 ;;rcx will hold old stack size 
                                 mov rcx, [rbp+3*8] ;;n , rbp the old one 
                                 add rcx, 4 ;; 4 - until first arg
                                 shl rcx, 3 ;;old stack size
                                 add rcx, 8 ;;for the magic  
                                 ;;rdx will hold the size of new stack 
                                 mov rdx, [rsp+3*8] ;;new n 
                                 add rdx, 4 ;; 4 - until first arg
                                 shl rdx, 3 ;;new stack size
                                 add rdx, 8 ;;for the magic  
                                 add rdx, 8 ;;for rbp 
                                 ;;rdi will hold the dest. dest = (old size- new size)*8 + rbp 
                                 mov rdi, rcx 
                                 sub rdi, rdx ;;rdi = rcx - rdx 
                                 add rdi, rbp ;;address of dest 
                                 mov rbp, [rbp]
                                 push rbp ;;old rbp 
                                 ;;rsi will hold the source
                                 mov rsi, rsp 
                                 call memmove
                                 mov rsp, rax ;;address of new stack 
                                 pop rbp ;;old rbp 
                                 pop rax ;;closure 
                                 CLOSURE_CODE rbx, rax
                                 jmp rbx 
leave
    ret 
Lcont221:
leave
    ret 
Lcont222:
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
cmp byte [rax], T_CLOSURE 

   jne L_total_exit
   CLOSURE_ENV rbx, rax
   push rbx 
   CLOSURE_CODE rbx, rax
   call rbx
   ;;after returning 
   add rsp, 8 ;;pop env
   pop rbx ;;rbx = number of args
   shl rbx, 3 ;; rbx = rbx*8
   add rsp, rbx ;;pop args
   add rsp, 8 ;;pop magic
	call write_sob_if_not_void
L_total_exit: ;;add index!!!!!!!!!!!!!!

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

car:
    push rbp
    mov rbp, rsp 

    mov rsi, PVAR(0)
    cmp byte [rsi], T_PAIR 
    jne .bad_return  ;;what to do if it is not a pair 
    mov rax, qword [rsi + TYPE_SIZE]
.return:
    leave
    ret 
.bad_return:
    leave
    ret 

cdr:
    push rbp
    mov rbp, rsp 

    mov rsi, PVAR(0)
    cmp byte [rsi], T_PAIR 
    jne .bad_return  ;;what to do if it is not a pair 
    mov rax, qword [rsi + TYPE_SIZE+ WORD_SIZE]
.return:
    leave
    ret
.bad_return:
    leave
    ret 

cons:
    push rbp
    mov rbp, rsp 

    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    MAKE_PAIR(rax, rsi, rdi) 
    leave
    ret 
    
set_car:
    push rbp
    mov rbp, rsp 

    mov rsi, PVAR(0) ;;pair
    mov rdi, PVAR(1) ;;obj
    
    mov [rsi+TYPE_SIZE], rdi 
    mov rax, SOB_VOID_ADDRESS
    leave
    ret 

set_cdr:
    push rbp
    mov rbp, rsp 

    mov rsi, PVAR(0) ;;pair
    mov rdi, PVAR(1) ;;obj
    
    mov [rsi+TYPE_SIZE+WORD_SIZE], rdi 
    mov rax, SOB_VOID_ADDRESS
    leave
    ret 

apply:
    push rbp 
    mov rbp, rsp 
    push qword 12345678 ;;push magic 

    mov rsi, PVAR(0) ;;closure scheme object 
    mov rdx, [rbp + 8*3] ;;get number of args
    dec rdx  
    mov rdi, PVAR(rdx) ;;get last arg = pair of args  
    mov rcx, 0 
.push_args_from_0_to_n:
    cmp rdi, SOB_NIL_ADDRESS
    je .push_args_from_n_to_0
    push qword [rdi + TYPE_SIZE] ;;car of pair
    mov rdi, [rdi + TYPE_SIZE + WORD_SIZE] ;;cdr of pair which is also a pair  
    inc rcx 
    jmp .push_args_from_0_to_n

.push_args_from_n_to_0: ;;turn the stack 
    mov rbx, 0 
    mov rdx, rsp ;;rdx points to args n that we pushed before and on top of him all the args from 0 to n-1 
.args_on_stack_n_to_0:
    cmp rbx, rcx ;;rcx = number of args 
    je .override_old_push_args
    push qword [rdx + rbx*8]    
    inc rbx
    jmp .args_on_stack_n_to_0

.override_old_push_args:
    mov rbx, 0 
    mov rax, rcx ;;num of args
    shl rax, 3 ;;mul rax*8
    add rax, rsp ;; points to previous stack that was arrange with args0 to argn 
.override:
    cmp rbx, rcx ;;rbx = number of args 
    je .push_regular_args
    pop rdx ;;arg 0 
    mov [rax + rbx*8], rdx 
    inc rbx 
    jmp .override 

.push_regular_args:
    mov rdx, [rbp + 8*3] ;;get number of args
    sub rdx, 2  ;;number of regular args 

    add rcx, rdx ;;number of all args 

    mov rbx, 0 
    mov rax, rdx ;;number of regular args 
    inc rax ;;for the first argument- the function 
    add rax, 3 ;;for ret, env, n 
    shl rax, 3 ;;mul rax*8 
    add rax, rbp 
    ;;rax is the address of the first regular arg after the list 
.start_push_regular: 
    cmp rbx, rdx 
    je .call_function 
    push qword [rax]
    sub rax, 8 ;;for the lower arg 
    inc rbx
    jmp .start_push_regular

.call_function:
    push rcx ;;number of args 
    CLOSURE_ENV rbx, rsi ;;env of closure
   push rbx 
   CLOSURE_CODE rbx, rsi ;;code 
   call rbx
    ;;ret from function 
    add rsp, 8 ;;pop env
    pop rbx ;;pop num of args 
    shl rbx, 3 ;;mul rbx*8 
    add rsp, rbx 
    add rsp,8 ;;for magic 
    leave
    ret 
    

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    mov rbx, qword [rsi+TYPE_SIZE]
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


